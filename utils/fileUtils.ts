import { TranscriptSegment, AnalysisResult } from '../types';

export const fileToBase64 = (file: File): Promise<string> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      if (typeof reader.result === 'string') {
        // Remove the data URL prefix (e.g., "data:audio/mp3;base64,")
        const base64String = reader.result.split(',')[1];
        resolve(base64String);
      } else {
        reject(new Error('Failed to convert file to base64'));
      }
    };
    reader.onerror = (error) => reject(error);
  });
};

export const formatTime = (seconds: number): string => {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, '0')}`;
};

export const getAudioDuration = (file: File): Promise<string> => {
  return new Promise((resolve) => {
    const objectUrl = URL.createObjectURL(file);
    const audio = document.createElement('audio');
    
    audio.onloadedmetadata = () => {
      const totalSeconds = Math.floor(audio.duration);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      URL.revokeObjectURL(objectUrl);
      resolve(`${minutes}:${seconds.toString().padStart(2, '0')}`);
    };

    audio.onerror = () => {
      URL.revokeObjectURL(objectUrl);
      resolve("--:--");
    };

    audio.src = objectUrl;
  });
};

export const downloadTranscriptAsCsv = (transcript: TranscriptSegment[], fileName: string) => {
  const headers = ['Speaker', 'Start Time', 'End Time', 'Text'];
  const rows = transcript.map(t => {
    // Escape quotes in text
    const escapedText = t.text.replace(/"/g, '""');
    return `"${t.speaker}","${t.timestamp}","${t.endTime || ''}","${escapedText}"`;
  });
  
  const csvContent = [headers.join(','), ...rows].join('\n');
  
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  if (link.download !== undefined) {
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', `${fileName.replace(/\.[^/.]+$/, "")}_transcript.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
};

export const downloadFullAnalysisAsCsv = (data: AnalysisResult, fileName: string) => {
  const bom = "\uFEFF"; // Byte Order Mark for Excel compatibility to display UTF-8 correctly
  
  // Clean helper
  const clean = (str: string) => str ? str.replace(/"/g, '""') : '';

  // --- SECTION 1: REPORT HEADER & SUMMARY ---
  let csvContent = `Report Name,${clean(fileName)}\n`;
  csvContent += `Generated By,SalesIQ AI\n`;
  csvContent += `Summary,"${clean(data.summary)}"\n`;
  csvContent += `Key Topics,"${clean(data.topics.join('; '))}"\n\n`;

  // --- SECTION 2: COACHING ---
  csvContent += `COACHING INSIGHTS\n`;
  csvContent += `Type,Insight\n`;
  data.coaching.strengths.forEach(s => csvContent += `Strength,"${clean(s)}"\n`);
  data.coaching.improvements.forEach(i => csvContent += `Improvement,"${clean(i)}"\n`);
  csvContent += `\n`;

  // --- SECTION 3: TRANSCRIPT ---
  csvContent += `FULL TRANSCRIPT\n`;
  csvContent += `Speaker,Start Time,End Time,Text\n`;
  
  data.transcript.forEach(t => {
     csvContent += `"${clean(t.speaker)}","${clean(t.timestamp)}","${clean(t.endTime || '')}","${clean(t.text)}"\n`;
  });

  // Create Blob and Download
  const blob = new Blob([bom + csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  if (link.download !== undefined) {
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', `${fileName.replace(/\.[^/.]+$/, "")}_full_report.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
};